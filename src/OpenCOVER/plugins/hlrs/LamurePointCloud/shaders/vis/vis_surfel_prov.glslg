#version 420 core

layout(points) in;
layout(triangle_strip, max_vertices = 4) out;

in VertexData {
    vec3  pass_ms_u;
    vec3  pass_ms_v;
    vec3  pass_point_color;
    vec3  pass_world_pos;
    vec3  pass_normal_ws;
    float pass_radius_ws; // Radius (WS)
    float pass_prov1;
    float pass_prov2;
    float pass_prov3;
    float pass_prov4;
    float pass_prov5;
    float pass_prov6;
} VertexIn[];

uniform mat4  mvp_matrix;
uniform vec2  viewport;        // bleibt für Konsistenz, hier nicht benötigt
uniform float min_screen_size;   // Pixel-Radius min
uniform float max_screen_size;   // Pixel-Radius max
uniform float scale_projection;

out FS_IN {
    vec3  pass_point_color;
    vec2  pass_uv_coords;
    vec3  pass_world_pos;
    vec3  pass_normal_ws;
    float pass_radius_ws;     // Radius (WS) NACH Pixel-Clamp
    float pass_prov1;
    float pass_prov2;
    float pass_prov3;
    float pass_prov4;
    float pass_prov5;
    float pass_prov6;
    float pass_screen_size;   // Pixel-Radius NACH Clamp
} gOut;

void main() {
    // Weiterreichen
    gOut.pass_point_color = VertexIn[0].pass_point_color;
    gOut.pass_world_pos   = VertexIn[0].pass_world_pos;
    gOut.pass_normal_ws   = VertexIn[0].pass_normal_ws;
    gOut.pass_prov1       = VertexIn[0].pass_prov1;
    gOut.pass_prov2       = VertexIn[0].pass_prov2;
    gOut.pass_prov3       = VertexIn[0].pass_prov3;
    gOut.pass_prov4       = VertexIn[0].pass_prov4;
    gOut.pass_prov5       = VertexIn[0].pass_prov5;
    gOut.pass_prov6       = VertexIn[0].pass_prov6;

    vec3 center = VertexIn[0].pass_world_pos;
    vec3 step_u = VertexIn[0].pass_ms_u; // Halbachsen (WS-Radius)
    vec3 step_v = VertexIn[0].pass_ms_v;

    // Pixel-Radius aus WS-Radius via w-Division
    float w0  = max(1e-6, abs(gl_in[0].gl_Position.w));
    float Rpx = (VertexIn[0].pass_radius_ws * scale_projection) / w0;      // Pixel-RADIUS
    float RpxC = clamp(Rpx, min_screen_size, max_screen_size);                  // Clamp in Pixeln
    float s = (Rpx > 0.0) ? (RpxC / Rpx) : 1.0;                             // isotrop skalieren

    step_u *= s;
    step_v *= s;

    // zurück-projizierter WS-Radius nach Clamp + Pixelradius für Debug
    gOut.pass_radius_ws   = VertexIn[0].pass_radius_ws * s;                 // Radius (WS)
    gOut.pass_screen_size = RpxC;                                           // Radius (px)

    // Quad-Ecken
    vec3 offs[4] = vec3[4](
        -step_u - step_v,
         step_u - step_v,
        -step_u + step_v,
         step_u + step_v
    );
    vec2 uvs[4] = vec2[4](
        vec2(-1.0, -1.0),
        vec2( 1.0, -1.0),
        vec2(-1.0,  1.0),
        vec2( 1.0,  1.0)
    );

    for (int i = 0; i < 4; ++i) {
        gOut.pass_uv_coords = uvs[i];
        gl_Position = mvp_matrix * vec4(center + offs[i], 1.0);
        EmitVertex();
    }
    EndPrimitive();
}
